<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Flashcards ‚Ä¢ New Session</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;600;700&family=Noto+Sans:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="/styles/new-common.css" />
    <link rel="stylesheet" href="/styles/index-new.css" />
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <link rel="icon" href="/favicon.ico" type="image/x-icon" />
  </head>
  <body>
    <div class="glow" aria-hidden="true"></div>
    <header>
      <div class="topbar">
        <div class="brand">
          <div class="logo">PP</div>
          <div>
            <div class="brand-name">Paramedic Prep</div>
            <!-- <div class="brand-sub">Adaptive learning deck</div> -->
          </div>
        </div>
        <div id="userArea" class="user-area"></div>
        <div class="select-block">
          <!-- <label for="deckSelect">Current lesson</label> -->
          <div class="select-wrap deck-select-wrap">
            <button type="button" id="deckSelectBtn" class="deck-select-btn" aria-label="Deck selector">
              <span id="deckSelectText">All lessons</span>
              <span class="chevron">‚ñæ</span>
            </button>
            <div id="deckSelectDropdown" class="deck-select-dropdown" aria-hidden="true">
              <div class="deck-select-item" data-deck-id="all">
                <input type="checkbox" id="deck-all" class="deck-checkbox">
                <label for="deck-all" class="deck-label">All</label>
              </div>
              <div id="deckSelectList" class="deck-select-list"></div>
            </div>
          </div>
        </div>
        <div class="progress-short">
          <div class="pill" id="progressShort">0 / 0</div>
        </div>
      </div>
    </header>
    <main>
      <div class="layout">
        <section class="session">
          <div class="session-head">
            <div class="session-title">
              <h2>Session Progress</h2>
              <span class="muted" id="sessionMeta">Loading...</span>
            </div>
            <div class="pill-stack" id="pillRow"></div>
          </div>
          <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
          </div>
          <div class="cards-grid">
            <article class="card">
              <div class="card-header">
                <span class="" id="deckBadge"></span>
                <div class="rating">
                  <button id="ratingUp" class="rate-btn" title="Thumbs up">üëç</button>
                  <button id="ratingDown" class="rate-btn" title="Thumbs down">üëé</button>
                </div>
              </div>
              <div id="imageFrame"></div>
              <div class="card-title" id="question">Loading‚Ä¶</div>
              <div class="status-row">
                <span class="muted" id="status">Stay focused</span>
              </div>
            </article>
            <article class="card answer-card">
              <div class="answer-title">
                <span>Answer</span>
                <button id="revealBtn" class="reveal-btn" type="button">Reveal (Space)</button>
              </div>
              <div id="answerImageFrame" class="answer-media"></div>
              <div class="answer-text" id="answer"></div>
              <div class="status-row muted" id="cardStats"></div>
            </article>
          </div>
          <div class="category-row" id="controls"></div>
          <div class="nav-row">
            <div class="rating muted" id="progress"></div>
            <div class="rating">
              <button class="btn" id="prevBtn" type="button">Previous</button>
              <button class="btn primary" id="nextBtn" type="button">Next</button>
            </div>
          </div>
        </section>
        <div id="emptyState" class="empty-state" style="display: none;">Please log in to view decks.</div>
      </div>
    </main>

    <div class="report-overlay" id="reportPanel" aria-hidden="true">
      <div class="report-card">
        <div class="report-head">
          <div>
            <div class="eyebrow">Profile</div>
            <h3>Lesson reports</h3>
            <div class="muted" id="reportSubtitle">Loading your progress...</div>
          </div>
          <div class="report-actions">
            <div class="report-legend" id="reportLegend"></div>
            <button class="btn" id="reportClose" type="button">Close</button>
          </div>
        </div>
        <div class="report-grid" id="reportGrid"></div>
      </div>
    </div>

    <div class="img-modal" id="imageModal" aria-hidden="true">
      <div class="img-modal-content">
        <button class="img-modal-close" id="imageModalClose" type="button" aria-label="Close image preview">‚úï</button>
        <img id="modalImage" alt="Expanded card image" />
        <div class="img-modal-hint">Click outside the image or press Esc to close</div>
      </div>
    </div>

    <div class="auth-panel" id="authPanel">
      <div class="auth-card">
        <h2 id="authTitle">Login</h2>
        <label for="authEmail">Email</label>
        <input id="authEmail" type="email" autocomplete="email" />
        <label for="authPassword">Password</label>
        <input id="authPassword" type="password" autocomplete="current-password" />
        <div id="nameRow">
          <label for="authName">Name</label>
          <input id="authName" type="text" autocomplete="name" />
        </div>
        <div class="auth-actions">
          <button id="authSubmit" class="btn primary" type="button">Submit</button>
          <button id="authCancel" class="linkish" type="button">Cancel</button>
        </div>
        <div class="muted" id="authStatus"></div>
      </div>
    </div>

    <script>
      const deckSelectBtn = document.getElementById("deckSelectBtn");
      const deckSelectText = document.getElementById("deckSelectText");
      const deckSelectDropdown = document.getElementById("deckSelectDropdown");
      const deckSelectList = document.getElementById("deckSelectList");
      const deckAllCheckbox = document.getElementById("deck-all");
      let selectedDecks = new Set();
      const questionEl = document.getElementById("question");
      const answerEl = document.getElementById("answer");
      const progressEl = document.getElementById("progress");
      const progressShortEl = document.getElementById("progressShort");
      const statusEl = document.getElementById("status");
      const cardStatsEl = document.getElementById("cardStats");
      const pillRow = document.getElementById("pillRow");
      const controls = document.getElementById("controls");
      const prevBtn = document.getElementById("prevBtn");
      const nextBtn = document.getElementById("nextBtn");
      const ratingUp = document.getElementById("ratingUp");
      const ratingDown = document.getElementById("ratingDown");
      const userArea = document.getElementById("userArea");
      const authPanel = document.getElementById("authPanel");
      const authTitle = document.getElementById("authTitle");
      const authEmail = document.getElementById("authEmail");
      const authPassword = document.getElementById("authPassword");
      const authName = document.getElementById("authName");
      const nameRow = document.getElementById("nameRow");
      const authSubmit = document.getElementById("authSubmit");
      const authCancel = document.getElementById("authCancel");
      const authStatus = document.getElementById("authStatus");
      const revealBtn = document.getElementById("revealBtn");
      const deckBadge = document.getElementById("deckBadge");
      const progressFill = document.getElementById("progressFill");
      const sessionMeta = document.getElementById("sessionMeta");
      const imageFrame = document.getElementById("imageFrame");
      const answerImageFrame = document.getElementById("answerImageFrame");
      const imageModal = document.getElementById("imageModal");
      const modalImage = document.getElementById("modalImage");
      const imageModalClose = document.getElementById("imageModalClose");
      const emptyState = document.getElementById("emptyState");
      const reportPanel = document.getElementById("reportPanel");
      const reportGrid = document.getElementById("reportGrid");
      const reportSubtitle = document.getElementById("reportSubtitle");
      const reportClose = document.getElementById("reportClose");
      const reportLegend = document.getElementById("reportLegend");

      const ALL_DECK_VALUE = "all";
      const DEFAULT_CATEGORIES = ["Again", "Hard", "Good", "Easy"];

      let deck = null;
      let deckList = [];
      let allCards = [];
      let cards = [];
      let index = 0;
      let categories = [];
      let progressMap = {};
      let showAnswer = false;
      let images = {};
      let answerImages = {};
      let ratings = {};
      let activeFilters = new Set();
      let currentUser = null;
      let authMode = "login";
      let reportData = [];
      let history = [];
      let historyIndex = -1;
      let seenThisSession = new Set();
      let activeUserMenu = null;

      document.addEventListener("click", closeUserMenu);
      document.addEventListener("click", (e) => {
        if (!deckSelectBtn.contains(e.target) && !deckSelectDropdown.contains(e.target)) {
          closeDeckDropdown();
        }
      });

      init();

      async function init() {
        prevBtn.addEventListener("click", () => move(-1));
        nextBtn.addEventListener("click", () => move(1));
        ratingUp.addEventListener("click", () => selectRating("up"));
        ratingDown.addEventListener("click", () => selectRating("down"));
        authSubmit.onclick = submitAuth;
        authCancel.onclick = closeAuth;
        revealBtn.onclick = reveal;
        reportClose.onclick = closeReports;
        reportPanel.addEventListener("click", (e) => {
          if (e.target === reportPanel) closeReports();
        });
        imageModal.addEventListener("click", (e) => {
          if (e.target === imageModal) closeImageModal();
        });
        imageModalClose.addEventListener("click", closeImageModal);
        deckSelectBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          toggleDeckDropdown();
        });
        
        // Setup All checkbox handler
        deckAllCheckbox.addEventListener("click", (e) => {
          e.stopPropagation();
          if (deckAllCheckbox.checked) {
            selectAllDecks();
          } else {
            deselectAllDecks();
          }
        });
        
        // Setup All label and item click handler
        const allItem = deckAllCheckbox.closest(".deck-select-item");
        if (allItem) {
          const allLabel = allItem.querySelector(".deck-label");
          
          // Label click - select all
          if (allLabel) {
            allLabel.addEventListener("click", (e) => {
              e.stopPropagation();
              e.preventDefault();
              selectAllDecks();
            });
          }
          
          // Item click (anywhere except checkbox) - select all
          allItem.addEventListener("click", (e) => {
            // Don't interfere if clicking directly on checkbox
            if (e.target === deckAllCheckbox) return;
            e.stopPropagation();
            selectAllDecks();
          });
        }
        
        window.addEventListener("keydown", handleKeys);
        await loadMe();
        renderUserArea();
        if (!currentUser) {
          showAuthPrompt();
          return;
        }
        await loadDecks();
      }

      function toggleDeckDropdown() {
        const isOpen = deckSelectDropdown.getAttribute("aria-hidden") === "false";
        if (isOpen) {
          closeDeckDropdown();
        } else {
          openDeckDropdown();
        }
      }

      function openDeckDropdown() {
        deckSelectDropdown.setAttribute("aria-hidden", "false");
        deckSelectDropdown.classList.add("open");
      }

      function closeDeckDropdown() {
        deckSelectDropdown.setAttribute("aria-hidden", "true");
        deckSelectDropdown.classList.remove("open");
      }

      async function loadDecks() {
        const res = await fetch("/api/decks");
        if (!res.ok) {
          showAuthPrompt();
          return;
        }
        const data = await res.json();
        deckList = data.decks || [];
        renderDeckDropdown();
        // Initially select all decks
        selectedDecks.clear();
        deckList.forEach((d) => selectedDecks.add(String(d.id)));
        deckAllCheckbox.checked = true;
        updateDeckSelectText();
        await loadSelectedDecks();
      }

      function renderDeckDropdown() {
        deckSelectList.innerHTML = "";
        deckList.forEach((deck) => {
          const item = document.createElement("div");
          item.className = "deck-select-item";
          item.dataset.deckId = String(deck.id);
          
          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.id = `deck-${deck.id}`;
          checkbox.className = "deck-checkbox";
          checkbox.checked = selectedDecks.has(String(deck.id));
          
          const label = document.createElement("label");
          label.htmlFor = `deck-${deck.id}`;
          label.className = "deck-label";
          label.textContent = deck.title;
          
          // Checkbox click - toggle selection
          checkbox.addEventListener("click", (e) => {
            e.stopPropagation();
            toggleDeckSelection(String(deck.id));
          });
          
          // Label or item click - select only this deck (single selection)
          label.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            selectOnlyDeck(String(deck.id));
          });
          
          // Item click (anywhere except checkbox) - select only this deck
          item.addEventListener("click", (e) => {
            // Don't interfere if clicking directly on checkbox
            if (e.target === checkbox) return;
            e.stopPropagation();
            selectOnlyDeck(String(deck.id));
          });
          
          item.appendChild(checkbox);
          item.appendChild(label);
          deckSelectList.appendChild(item);
        });
        
        // Update All checkbox state
        deckAllCheckbox.checked = selectedDecks.size === deckList.length;
      }

      function toggleDeckSelection(deckId) {
        if (selectedDecks.has(deckId)) {
          selectedDecks.delete(deckId);
        } else {
          selectedDecks.add(deckId);
        }
        updateAllCheckboxState();
        updateDeckSelectText();
        updateCheckboxStates();
        loadSelectedDecks();
      }

      function selectOnlyDeck(deckId) {
        selectedDecks.clear();
        selectedDecks.add(deckId);
        updateAllCheckboxState();
        updateDeckSelectText();
        updateCheckboxStates();
        loadSelectedDecks();
      }

      function selectAllDecks() {
        selectedDecks.clear();
        deckList.forEach((d) => selectedDecks.add(String(d.id)));
        updateAllCheckboxState();
        updateDeckSelectText();
        updateCheckboxStates();
        loadSelectedDecks();
      }

      function deselectAllDecks() {
        selectedDecks.clear();
        updateAllCheckboxState();
        updateDeckSelectText();
        updateCheckboxStates();
        if (selectedDecks.size === 0) {
          // If nothing selected, show empty state
          showNoDecks();
        } else {
          loadSelectedDecks();
        }
      }

      function selectAllDecks() {
        selectedDecks.clear();
        deckList.forEach((d) => selectedDecks.add(String(d.id)));
        updateAllCheckboxState();
        updateDeckSelectText();
        updateCheckboxStates();
        loadSelectedDecks();
      }

      function deselectAllDecks() {
        selectedDecks.clear();
        updateAllCheckboxState();
        updateDeckSelectText();
        updateCheckboxStates();
        if (selectedDecks.size === 0) {
          // If nothing selected, show empty state
          showNoDecks();
        } else {
          loadSelectedDecks();
        }
      }

      function updateAllCheckboxState() {
        deckAllCheckbox.checked = selectedDecks.size === deckList.length;
      }

      function updateCheckboxStates() {
        deckSelectList.querySelectorAll(".deck-checkbox").forEach((checkbox) => {
          const deckId = checkbox.id.replace("deck-", "");
          checkbox.checked = selectedDecks.has(deckId);
        });
      }

      function updateDeckSelectText() {
        if (selectedDecks.size === 0) {
          deckSelectText.textContent = "No lessons";
        } else if (selectedDecks.size === deckList.length) {
          deckSelectText.textContent = "All";
        } else if (selectedDecks.size === 1) {
          const deckId = Array.from(selectedDecks)[0];
          const deck = deckList.find((d) => String(d.id) === deckId);
          deckSelectText.textContent = deck ? deck.title : "1 lesson";
        } else {
          deckSelectText.textContent = `${selectedDecks.size} lessons`;
        }
      }

      async function loadSelectedDecks() {
        if (selectedDecks.size === 0) {
          showNoDecks();
          return;
        }
        if (selectedDecks.size === deckList.length) {
          await loadAllDecks();
          return;
        }
        const selectedIds = Array.from(selectedDecks);
        await loadMultipleDecks(selectedIds);
      }

      async function loadMultipleDecks(deckIds) {
        const details = await Promise.all(
          deckIds.map(async (id) => {
            const res = await fetch(`/api/decks/${id}`);
            if (!res.ok) return null;
            return res.json();
          })
        );
        const validDecks = details.filter(Boolean);
        if (!validDecks.length) {
          showNoDecks();
          return;
        }
        const combinedProgress = {};
        const combinedRatings = {};
        const combinedCards = [];
        validDecks.forEach((d) => {
          (d.cards || []).forEach((c) =>
            combinedCards.push({
              ...c,
              deckId: c.deckId || d.id,
              deckTitle: c.deckTitle || d.title,
            })
          );
          Object.entries(d.progress || {}).forEach(([key, value]) => {
            combinedProgress[key] = value;
          });
          Object.entries(d.ratings || {}).forEach(([key, value]) => {
            combinedRatings[key] = value;
          });
        });
        const titles = validDecks.map((d) => d.title).join(", ");
        setupSession({
          deckInfo: { id: "multiple", title: titles },
          cardList: combinedCards,
          progress: combinedProgress,
          ratingsMap: combinedRatings,
          categoryList: validDecks[0]?.categories || DEFAULT_CATEGORIES,
        });
      }

      async function loadDeck(id) {
        if (id === ALL_DECK_VALUE) {
          await loadAllDecks();
          return;
        }
        const res = await fetch(`/api/decks/${id}`);
        if (!res.ok) {
          showAuthPrompt();
          return;
        }
        const data = await res.json();
        const cardList = (data.cards || []).map((c) => ({
          ...c,
          deckId: c.deckId || data.id,
          deckTitle: c.deckTitle || data.title,
        }));
        setupSession({
          deckInfo: { id: data.id, title: data.title },
          cardList,
          progress: data.progress || {},
          ratingsMap: data.ratings || {},
          categoryList: data.categories || DEFAULT_CATEGORIES,
        });
      }

      async function loadAllDecks() {
        const meta = deckList.length ? deckList : [];
        if (!meta.length) {
          showNoDecks();
          return;
        }
        const details = await Promise.all(
          meta.map(async (d) => {
            const res = await fetch(`/api/decks/${d.id}`);
            if (!res.ok) return null;
            return res.json();
          })
        );
        const validDecks = details.filter(Boolean);
        if (!validDecks.length) {
          showNoDecks();
          return;
        }
        const combinedProgress = {};
        const combinedRatings = {};
        const combinedCards = [];
        validDecks.forEach((d) => {
          (d.cards || []).forEach((c) =>
            combinedCards.push({
              ...c,
              deckId: c.deckId || d.id,
              deckTitle: c.deckTitle || d.title,
            })
          );
          Object.entries(d.progress || {}).forEach(([key, value]) => {
            combinedProgress[key] = value;
          });
          Object.entries(d.ratings || {}).forEach(([key, value]) => {
            combinedRatings[key] = value;
          });
        });
        setupSession({
          deckInfo: { id: ALL_DECK_VALUE, title: "All lessons" },
          cardList: combinedCards,
          progress: combinedProgress,
          ratingsMap: combinedRatings,
          categoryList: validDecks[0]?.categories || DEFAULT_CATEGORIES,
        });
      }

      function setupSession({ deckInfo, cardList, progress = {}, ratingsMap = {}, categoryList = DEFAULT_CATEGORIES }) {
        deck = deckInfo;
        emptyState.style.display = "none";
        allCards = shuffle(cardList);
        cards = [...allCards];
        categories = categoryList && categoryList.length ? categoryList : DEFAULT_CATEGORIES;
        progressMap = progress || {};
        images = {};
        answerImages = {};
        ratings = ratingsMap || {};
        cards.forEach((c) => {
          if (c.image) images[String(c.id)] = c.image;
          if (c.answerImage) answerImages[String(c.id)] = c.answerImage;
        });
        index = 0;
        activeFilters = new Set();
        resetHistory();
        seenThisSession = new Set();
        renderCategories();
        const firstCard = pickNextCard();
        if (firstCard) {
          showCard(firstCard.id, { addToHistory: true });
        } else {
          renderCard();
        }
      }

      function showNoDecks() {
        questionEl.textContent = "No lessons available.";
        answerEl.textContent = "";
        pillRow.innerHTML = "";
        controls.innerHTML = "";
        progressEl.textContent = "";
        ratingUp.classList.remove("selected");
        ratingDown.classList.remove("selected");
        progressFill.style.width = "0%";
        sessionMeta.textContent = "Add a deck to begin studying.";
        emptyState.style.display = "block";
        deckBadge.textContent = "";
        deckBadge.style.display = "none";
      }

      function renderCategories() {
        controls.innerHTML = "";
        categories.forEach((cat) => {
          const btn = document.createElement("button");
          btn.className = "category-btn";
          btn.innerHTML = `<span>${cat}</span><span class="category-meta">Move card to ${cat}</span>`;
          btn.onclick = () => selectCategory(cat);
          btn.dataset.cat = cat.toLowerCase();
          btn.dataset.name = cat;
          controls.appendChild(btn);
        });
        decorateCategoryColors();
      }

      function decorateCategoryColors() {
        controls.querySelectorAll(".category-btn").forEach((btn) => {
          const cat = btn.dataset.cat || "";
          let color = "var(--accent)";
          if (cat.includes("again")) color = "var(--again)";
          if (cat.includes("hard")) color = "var(--hard)";
          if (cat.includes("good")) color = "var(--good)";
          if (cat.includes("easy")) color = "var(--accent-2)";
          btn.style.borderColor = color + "55";
          btn.style.color = "#e9f1ff";
        });
      }

      function renderCard() {
        renderPills();
        renderProgress();
        deckBadge.textContent = "";
        deckBadge.style.display = "none";
        if (!cards.length) {
          questionEl.textContent = activeFilters.size ? "No cards match the selected difficulties." : "No cards.";
          answerEl.textContent = "";
          statusEl.textContent = activeFilters.size ? "Clear or change filters to continue." : "";
          cardStatsEl.textContent = "";
          imageFrame.innerHTML = "";
          if (answerImageFrame) {
            answerImageFrame.innerHTML = "";
            answerImageFrame.style.display = "none";
          }
          ratingUp.classList.remove("selected");
          ratingDown.classList.remove("selected");
          return;
        }
        if (!cards[index]) index = 0;
        const card = cards[index];
        const badgeTitle = card.deckTitle || deck?.title || "";
        if (badgeTitle) {
          deckBadge.textContent = badgeTitle;
          deckBadge.style.display = "inline-block";
        }
        questionEl.textContent = card.question;
        answerEl.textContent = showAnswer ? card.answer : "Press reveal to view the answer.";
        const current = progressMap[String(card.id)];
        statusEl.textContent = current ? `You marked this as ${current}` : "Not yet rated";
        [...controls.children].forEach((btn) => {
          btn.classList.toggle("selected", btn.dataset.name === current);
        });
        renderRating();
        renderImages(card);
        // deckBadge.textContent = deck.title || "Deck";
        // cardStatsEl.textContent = `Card ${index + 1} of ${cards.length}`;
      }

      function renderProgress() {
        const total = cards.length;
        const visibleIds = new Set(cards.map((c) => String(c.id)));
        const done = Object.entries(progressMap).filter(([id]) => visibleIds.has(id)).length;
        const pct = total ? Math.round((done / total) * 100) : 0;
        const slide = `${cards.length ? index + 1 : 0} / ${total || 0}`;
        progressEl.textContent = slide;
        progressShortEl.textContent = `${done} / ${total || 0}`;
        progressFill.style.width = `${pct}%`;
        sessionMeta.textContent = `${pct}% complete ¬∑ ${done} of ${total} reviewed`;
      }

      function renderPills() {
        pillRow.innerHTML = "";
        const summary = countCategories();
        categories.forEach((cat) => {
          const pill = document.createElement("button");
          pill.type = "button";
          pill.className = "pill-small filter-pill";
          pill.textContent = `${cat}: ${summary[cat] || 0}`;
          pill.dataset.cat = cat;
          pill.classList.toggle("selected", activeFilters.has(cat));
          pill.onclick = () => toggleFilter(cat);
          pillRow.appendChild(pill);
        });
      }

      function countCategories() {
        const counts = {};
        Object.values(progressMap).forEach((cat) => {
          counts[cat] = (counts[cat] || 0) + 1;
        });
        return counts;
      }

      function resetHistory() {
        history = [];
        historyIndex = -1;
      }

      function showCard(cardId, { addToHistory = false } = {}) {
        const idx = cards.findIndex((c) => c.id === cardId);
        if (idx < 0) return false;
        index = idx;
        showAnswer = false;
        renderCard();
        seenThisSession.add(cardId);
        if (addToHistory) {
          history = history.slice(0, historyIndex + 1);
          history.push(cardId);
          historyIndex = history.length - 1;
        }
        return true;
      }

      function pickNextCard() {
        if (!cards.length) return null;
        const currentId = cards[index] ? cards[index].id : null;
        const unanswered = cards.filter((c) => !progressMap[String(c.id)]);
        if (unanswered.length) return chooseFresh(unanswered, currentId);

        const buckets = { Again: [], Hard: [], Good: [], Easy: [] };
        cards.forEach((card) => {
          const cat = progressMap[String(card.id)];
          if (buckets[cat]) buckets[cat].push(card);
        });

        // Bias toward tougher cards once everything has been answered.
        const weightedBuckets = [
          { cat: "Again", weight: 50 },
          { cat: "Hard", weight: 30 },
          { cat: "Good", weight: 20 },
          { cat: "Easy", weight: 10 },
        ].filter((entry) => buckets[entry.cat].length);

        if (!weightedBuckets.length) return chooseFresh(cards, currentId);

        const totalWeight = weightedBuckets.reduce((sum, entry) => sum + entry.weight, 0);
        let roll = Math.random() * totalWeight;
        let chosenCat = weightedBuckets[weightedBuckets.length - 1].cat;
        for (const entry of weightedBuckets) {
          if (roll <= entry.weight) {
            chosenCat = entry.cat;
            break;
          }
          roll -= entry.weight;
        }
        const pool = buckets[chosenCat];
        if (!pool || !pool.length) return chooseFresh(cards, currentId);
        return chooseFresh(pool, currentId);
      }

      function randomItem(list) {
        if (!list.length) return null;
        return list[Math.floor(Math.random() * list.length)];
      }

      function chooseFresh(list, excludeId = null) {
        if (!list.length) return null;
        const filtered = excludeId === null ? list : list.filter((c) => c.id !== excludeId);
        const pool = filtered.length ? filtered : list; // allow repeat if only one option
        const unseen = pool.filter((c) => !seenThisSession.has(c.id));
        if (unseen.length) return randomItem(unseen);
        return randomItem(pool);
      }

      function move(step) {
        if (!cards.length) return;
        if (step === -1) {
          const prevId = history[historyIndex - 1];
          if (prevId !== undefined && cards.some((c) => c.id === prevId)) {
            historyIndex -= 1;
            showCard(prevId);
          }
          return;
        }

        const forwardId = history[historyIndex + 1];
        if (forwardId !== undefined && cards.some((c) => c.id === forwardId)) {
          historyIndex += 1;
          showCard(forwardId);
          return;
        }

        const nextCard = pickNextCard();
        if (nextCard) showCard(nextCard.id, { addToHistory: true });
      }

      function toggleFilter(cat) {
        if (activeFilters.has(cat)) {
          activeFilters.delete(cat);
        } else {
          activeFilters.add(cat);
        }
        applyFilters({ preserveIndex: true });
      }

      function applyFilters({ preserveIndex } = {}) {
        const currentId = preserveIndex && cards[index] ? cards[index].id : null;
        if (!activeFilters.size) {
          cards = [...allCards];
        } else {
          const selected = activeFilters;
          cards = allCards.filter((card) => selected.has(progressMap[String(card.id)]));
        }
        showAnswer = false;
        const stillHasCurrent = currentId && cards.some((c) => c.id === currentId);
        if (stillHasCurrent) {
          index = cards.findIndex((c) => c.id === currentId);
          renderCard();
          return;
        }
        resetHistory();
        seenThisSession = new Set();
        const nextCard = pickNextCard();
        if (nextCard) {
          showCard(nextCard.id, { addToHistory: true });
        } else {
          renderCard();
        }
      }

      async function selectCategory(cat) {
        if (!cards[index]) return;
        const card = cards[index];
        const key = String(card.id);
        const targetDeckId = card.deckId || deck?.id;
        progressMap[key] = cat;
        applyFilters({ preserveIndex: true });
        await fetch(`/api/decks/${targetDeckId}/progress`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ cardId: card.id, category: cat }),
        });
        move(1);
      }

      function reveal() {
        showAnswer = true;
        renderCard();
      }

      function shuffle(list) {
        const arr = [...list];
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      }

      function renderImages(card) {
        const key = String(card.id);
        const questionUrl = images[key];
        const answerUrl = answerImages[key];
        renderImageInto(imageFrame, questionUrl);
        if (showAnswer) {
          renderImageInto(answerImageFrame, answerUrl);
        } else if (answerImageFrame) {
          answerImageFrame.innerHTML = "";
          answerImageFrame.style.display = "none";
        }
      }

      function renderImageInto(frame, url) {
        if (!frame) return;
        frame.innerHTML = "";
        if (!url) {
          frame.style.display = "none";
          return;
        }
        frame.style.display = "block";
        const img = document.createElement("img");
        img.src = url;
        img.alt = "Card image";
        img.className = "question-img";
        img.addEventListener("click", () => openImageModal(url));
        frame.appendChild(img);
      }

      function renderRating() {
        if (!cards[index]) return;
        const card = cards[index];
        const key = String(card.id);
        const current = ratings[key];
        ratingUp.classList.toggle("selected", current === "up");
        ratingDown.classList.toggle("selected", current === "down");
      }

      async function selectRating(choice) {
        if (!cards[index]) return;
        const card = cards[index];
        const key = String(card.id);
        const newRating = ratings[key] === choice ? null : choice;
        const targetDeckId = card.deckId || deck?.id;
        ratings[key] = newRating;
        renderRating();
        await fetch(`/api/decks/${targetDeckId}/rating`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ cardId: card.id, rating: newRating }),
        });
      }

      async function loadMe() {
        const res = await fetch("/api/me");
        if (!res.ok) {
          currentUser = null;
          return;
        }
        const data = await res.json();
        currentUser = data.user;
      }

      function renderUserArea() {
        userArea.innerHTML = "";
        activeUserMenu = null;
        if (!currentUser) {
          const loginBtn = document.createElement("button");
          loginBtn.textContent = "Login";
          loginBtn.className = "btn";
          loginBtn.onclick = () => openAuth("login");
          const regBtn = document.createElement("button");
          regBtn.textContent = "Sign up";
          regBtn.className = "btn primary";
          regBtn.onclick = () => openAuth("register");
          userArea.appendChild(loginBtn);
          userArea.appendChild(regBtn);
        } else {
          const dropdown = document.createElement("div");
          dropdown.className = "user-dropdown";
          dropdown.addEventListener("click", (e) => e.stopPropagation());

          const trigger = document.createElement("button");
          trigger.type = "button";
          trigger.className = "avatar-btn";
          trigger.title = `${currentUser.name || currentUser.email} (${currentUser.email})`;

          const avatar = document.createElement("div");
          avatar.className = "avatar";
          avatar.textContent = initials(currentUser.name || currentUser.email);

          const caret = document.createElement("span");
          caret.className = "user-caret";
          caret.textContent = "‚ñæ";

          trigger.appendChild(avatar);
          trigger.appendChild(caret);

          const menu = document.createElement("div");
          menu.className = "user-menu";
          menu.addEventListener("click", (e) => e.stopPropagation());

          const addMenuItem = ({ label, onClick, href }) => {
            const el = document.createElement(href ? "a" : "button");
            el.className = "menu-item";
            el.textContent = label;
            if (href) {
              el.href = href;
              el.onclick = () => closeUserMenu();
            } else if (onClick) {
              el.type = "button";
              el.onclick = () => {
                onClick();
                closeUserMenu();
              };
            }
            menu.appendChild(el);
          };

          if (currentUser.is_admin) {
            addMenuItem({ label: "Admin", href: "/admin.html" });
            addMenuItem({ label: "Users", href: "/admin-users.html" });
          }
          addMenuItem({ label: "Reports", onClick: openReports });
          addMenuItem({ label: "Logout", onClick: logout });

          trigger.addEventListener("click", (e) => {
            e.stopPropagation();
            const isOpen = dropdown.classList.contains("open");
            closeUserMenu();
            if (!isOpen) {
              dropdown.classList.add("open");
              activeUserMenu = dropdown;
            }
          });

          dropdown.appendChild(trigger);
          dropdown.appendChild(menu);
          userArea.appendChild(dropdown);
        }
      }

      function closeUserMenu() {
        if (activeUserMenu) {
          activeUserMenu.classList.remove("open");
          activeUserMenu = null;
        }
      }

      function openAuth(mode) {
        authMode = mode;
        authTitle.textContent = mode === "login" ? "Login" : "Create account";
        nameRow.style.display = mode === "login" ? "none" : "block";
        authStatus.textContent = "";
        authEmail.value = "";
        authPassword.value = "";
        authName.value = "";
        authPanel.style.display = "flex";
      }

      function closeAuth() {
        authPanel.style.display = "none";
      }

      function switchAuthMode() {
        openAuth(authMode === "login" ? "register" : "login");
      }

      async function submitAuth() {
        authStatus.textContent = "";
        const email = authEmail.value.trim();
        const password = authPassword.value;
        const name = authName.value.trim();
        if (!email || !password || (authMode === "register" && !name)) {
          authStatus.textContent = "Please fill all fields.";
          return;
        }
        const payload = authMode === "login" ? { email, password } : { email, password, name };
        const res = await fetch(authMode === "login" ? "/api/auth/login" : "/api/auth/register", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        if (!res.ok) {
          const err = await res.json().catch(() => ({}));
          authStatus.textContent = err.error || "Auth failed";
          return;
        }
        const data = await res.json();
        currentUser = data.user;
        closeAuth();
        renderUserArea();
        await loadDecks();
        if (!cards.length) showAuthPrompt();
      }

      async function logout() {
        await fetch("/api/auth/logout", { method: "POST" });
        currentUser = null;
        ratings = {};
        progressMap = {};
        renderUserArea();
        showAuthPrompt();
      }

      function showAuthPrompt() {
        questionEl.textContent = "Please log in to view decks.";
        answerEl.textContent = "";
        pillRow.innerHTML = "";
        controls.innerHTML = "";
        controls.appendChild(createLoginButtons());
        progressEl.textContent = "";
        ratingUp.classList.remove("selected");
        ratingDown.classList.remove("selected");
        progressFill.style.width = "0%";
        sessionMeta.textContent = "Authentication required to load study decks.";
        emptyState.style.display = "block";
        renderUserArea();
      }

      function createLoginButtons() {
        const wrapper = document.createElement("div");
        wrapper.className = "row";
        const loginBtn = document.createElement("button");
        loginBtn.textContent = "Login";
        loginBtn.className = "btn";
        loginBtn.onclick = () => openAuth("login");
        const regBtn = document.createElement("button");
        regBtn.textContent = "Sign up";
        regBtn.className = "btn primary";
        regBtn.onclick = () => openAuth("register");
        wrapper.appendChild(loginBtn);
        wrapper.appendChild(regBtn);
        return wrapper;
      }

      async function openReports() {
        if (!currentUser) return;
        reportPanel.classList.add("open");
        reportPanel.setAttribute("aria-hidden", "false");
        await loadReports();
      }

      function closeReports() {
        reportPanel.classList.remove("open");
        reportPanel.setAttribute("aria-hidden", "true");
      }

      async function loadReports() {
        reportSubtitle.textContent = "Loading your progress...";
        reportGrid.innerHTML = "";
        renderLegend();
        const res = await fetch("/api/reports/progress");
        if (!res.ok) {
          reportSubtitle.textContent = "Unable to load reports right now.";
          return;
        }
        const data = await res.json();
        reportData = data.decks || [];
        renderReportGrid(reportData);
      }

      function renderReportGrid(decks) {
        if (!decks.length) {
          reportSubtitle.textContent = "No study activity yet. Answer a few cards to see insights.";
          reportGrid.innerHTML = "";
          return;
        }
        const totalAnswered = decks.reduce((sum, d) => sum + (d.answered || 0), 0);
        const totalCards = decks.reduce((sum, d) => sum + (d.totalCards || 0), 0);
        reportSubtitle.textContent = `${totalAnswered} of ${totalCards} cards answered across ${decks.length} lessons`;
        reportGrid.innerHTML = "";
        decks.forEach((deck) => {
          const wrapper = document.createElement("div");
          wrapper.className = "report-item";

          const row = document.createElement("div");
          row.className = "report-row";
          const left = document.createElement("div");
          left.innerHTML = `<div class="eyebrow">Lesson</div><div style="font-weight: 700; font-size: 16px;">${deck.title}</div>`;
          const pill = document.createElement("div");
          pill.className = "pill-small";
          pill.textContent = `${deck.answered} / ${deck.totalCards} answered`;
          row.appendChild(left);
          row.appendChild(pill);

          const barHolder = document.createElement("div");
          barHolder.className = "report-bar";
          drawStackedBar(barHolder, deck);

          const meta = document.createElement("div");
          meta.className = "report-meta";
          const pct = deck.totalCards ? Math.round((deck.answered / deck.totalCards) * 100) : 0;
          meta.innerHTML = `<span class="report-score">${pct}% complete</span><span>¬∑</span><span>${deck.unanswered} unanswered</span>`;

          wrapper.appendChild(row);
          wrapper.appendChild(barHolder);
          wrapper.appendChild(meta);
          reportGrid.appendChild(wrapper);
        });
      }

      function drawStackedBar(container, deck) {
        const total = deck.totalCards || 1;
        const data = [
          { key: "Again", value: deck.categories?.Again || 0, color: getReportColor("Again") },
          { key: "Hard", value: deck.categories?.Hard || 0, color: getReportColor("Hard") },
          { key: "Good", value: deck.categories?.Good || 0, color: getReportColor("Good") },
          { key: "Easy", value: deck.categories?.Easy || 0, color: getReportColor("Easy") },
          { key: "Unanswered", value: deck.unanswered || 0, color: getReportColor("Unanswered") },
        ];
        const width = 100;
        const height = container.clientHeight || 18;
        const svg = d3
          .select(container)
          .html("")
          .append("svg")
          .attr("width", "100%")
          .attr("height", height)
          .attr("viewBox", `0 0 ${width} ${height}`)
          .attr("preserveAspectRatio", "none");

        let x = 0;
        data.forEach((d) => {
          if (!d.value) return;
          const w = (d.value / total) * width;
          svg
            .append("rect")
            .attr("x", x)
            .attr("y", 0)
            .attr("width", Math.max(w, 0))
            .attr("height", height)
            .attr("fill", d.color);
          x += w;
        });
      }

      function getReportColor(key) {
        if (key === "Again") return "var(--report-again)";
        if (key === "Hard") return "var(--report-hard)";
        if (key === "Good") return "var(--report-good)";
        if (key === "Easy") return "var(--report-easy)";
        return "var(--report-unanswered)";
      }

      function renderLegend() {
        reportLegend.innerHTML = "";
        [
          { key: "Again", label: "Again", color: getReportColor("Again") },
          { key: "Hard", label: "Hard", color: getReportColor("Hard") },
          { key: "Good", label: "Good", color: getReportColor("Good") },
          { key: "Easy", label: "Easy", color: getReportColor("Easy") },
          { key: "Unanswered", label: "Unanswered", color: getReportColor("Unanswered") },
        ].forEach((item) => {
          const chip = document.createElement("div");
          chip.className = "legend-chip";
          const swatch = document.createElement("span");
          swatch.className = "legend-swatch";
          swatch.style.background = item.color;
          const text = document.createElement("span");
          text.textContent = item.label;
          chip.appendChild(swatch);
          chip.appendChild(text);
          reportLegend.appendChild(chip);
        });
      }

      function initials(str) {
        const parts = str.split(/\s+/).filter(Boolean);
        if (!parts.length) return "?";
        if (parts.length === 1) return parts[0].slice(0, 2).toUpperCase();
        return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
      }

      function handleKeys(e) {
        if (authPanel.style.display === "flex" || reportPanel.classList.contains("open") || imageModal.classList.contains("open")) {
          if (e.code === "Escape") {
            closeReports();
            closeImageModal();
          }
          return;
        }
        if (e.code === "Escape" && deckSelectDropdown.classList.contains("open")) {
          closeDeckDropdown();
          return;
        }
        if (isTyping(e.target)) return;
        const shortcutCategory = getShortcutCategory(e.code);
        if (shortcutCategory) {
          e.preventDefault();
          void selectCategory(shortcutCategory);
          return;
        }
        if (e.code === "ArrowRight") move(1);
        if (e.code === "ArrowLeft") move(-1);
        if (e.code === "Space") {
          e.preventDefault();
          if (!showAnswer) {
            reveal();
          }
        }
      }

      function isTyping(el) {
        if (!el) return false;
        const tag = el.tagName;
        return ["INPUT", "TEXTAREA", "SELECT"].includes(tag) || el.isContentEditable;
      }

      function getShortcutCategory(code) {
        const map = {
          Digit1: "Again",
          Numpad1: "Again",
          Digit2: "Hard",
          Numpad2: "Hard",
          Digit3: "Good",
          Numpad3: "Good",
          Digit4: "Easy",
          Numpad4: "Easy",
        };
        const desired = map[code];
        if (!desired) return null;
        const match = categories.find((cat) => cat.toLowerCase() === desired.toLowerCase());
        if (match) return match;
        const fallbackIdx = ["Again", "Hard", "Good", "Easy"].indexOf(desired);
        return fallbackIdx >= 0 ? categories[fallbackIdx] : null;
      }

      function openImageModal(url) {
        if (!url) return;
        modalImage.src = url;
        imageModal.classList.add("open");
        imageModal.setAttribute("aria-hidden", "false");
      }

      function closeImageModal() {
        imageModal.classList.remove("open");
        imageModal.setAttribute("aria-hidden", "true");
        modalImage.src = "";
      }
    </script>
  </body>
</html>
